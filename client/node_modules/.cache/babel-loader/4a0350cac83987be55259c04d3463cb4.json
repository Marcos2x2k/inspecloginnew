{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst {\n  Readable\n} = require('stream'); // Parameters for safe file name parsing.\n\n\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g;\nconst MAX_EXTENSION_LENGTH = 3; // Parameters to generate unique temporary file names:\n\nconst TEMP_COUNTER_MAX = 65536;\nconst TEMP_PREFIX = 'tmp';\nlet tempCounter = 0;\n/**\r\n * Logs message to console if debug option set to true.\r\n * @param {Object} options - options object.\r\n * @param {string} msg - message to log.\r\n * @returns {boolean} - false if debug is off.\r\n */\n\nconst debugLog = (options, msg) => {\n  const opts = options || {};\n  if (!opts.debug) return false;\n  console.log(`Express-file-upload: ${msg}`); // eslint-disable-line\n\n  return true;\n};\n/**\r\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\r\n * @param {string} prefix - a prefix for generated unique file name.\r\n * @returns {string}\r\n */\n\n\nconst getTempFilename = function () {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TEMP_PREFIX;\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;\n  return `${prefix}-${tempCounter}-${Date.now()}`;\n};\n/**\r\n * isFunc: Checks if argument is a function.\r\n * @returns {boolean} - Returns true if argument is a function.\r\n */\n\n\nconst isFunc = func => func && func.constructor && func.call && func.apply ? true : false;\n/**\r\n * Set errorFunc to the same value as successFunc for callback mode.\r\n * @returns {Function}\r\n */\n\n\nconst errorFunc = (resolve, reject) => isFunc(reject) ? reject : resolve;\n/**\r\n * Return a callback function for promise resole/reject args.\r\n * Ensures that callback is called only once.\r\n * @returns {Function}\r\n */\n\n\nconst promiseCallback = (resolve, reject) => {\n  let hasFired = false;\n  return err => {\n    if (hasFired) {\n      return;\n    }\n\n    hasFired = true;\n    return err ? errorFunc(resolve, reject)(err) : resolve();\n  };\n};\n/**\r\n * Builds instance options from arguments objects(can't be arrow function).\r\n * @returns {Object} - result options.\r\n */\n\n\nconst buildOptions = function () {\n  const result = {};\n  [...arguments].forEach(options => {\n    if (!options || typeof options !== 'object') return;\n    Object.keys(options).forEach(i => result[i] = options[i]);\n  });\n  return result;\n}; // The default prototypes for both objects and arrays.\n// Used by isSafeFromPollution\n\n\nconst OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype);\nconst ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype);\n/**\r\n * Determines whether a key insertion into an object could result in a prototype pollution\r\n * @param {Object} base - The object whose insertion we are checking\r\n * @param {string} key - The key that will be inserted\r\n */\n\nconst isSafeFromPollution = (base, key) => {\n  // We perform an instanceof check instead of Array.isArray as the former is more\n  // permissive for cases in which the object as an Array prototype but was not constructed\n  // via an Array constructor or literal.\n  const TOUCHES_ARRAY_PROTOTYPE = base instanceof Array && ARRAY_PROTOTYPE_KEYS.includes(key);\n  const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key);\n  return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE;\n};\n/**\r\n * Builds request fields (using to build req.body and req.files)\r\n * @param {Object} instance - request object.\r\n * @param {string} field - field name.\r\n * @param {any} value - field value.\r\n * @returns {Object}\r\n */\n\n\nconst buildFields = (instance, field, value) => {\n  // Do nothing if value is not set.\n  if (value === null || value === undefined) return instance;\n  instance = instance || Object.create(null);\n\n  if (!isSafeFromPollution(instance, field)) {\n    return instance;\n  } // Non-array fields\n\n\n  if (!instance[field]) {\n    instance[field] = value;\n    return instance;\n  } // Array fields\n\n\n  if (instance[field] instanceof Array) {\n    instance[field].push(value);\n  } else {\n    instance[field] = [instance[field], value];\n  }\n\n  return instance;\n};\n/**\r\n * Creates a folder for file specified in the path variable\r\n * @param {Object} fileUploadOptions\r\n * @param {string} filePath\r\n * @returns {boolean}\r\n */\n\n\nconst checkAndMakeDir = (fileUploadOptions, filePath) => {\n  // Check upload options were set.\n  if (!fileUploadOptions) return false;\n  if (!fileUploadOptions.createParentPath) return false; // Check whether folder for the file exists.\n\n  if (!filePath) return false;\n  const parentPath = path.dirname(filePath); // Create folder if it doesn't exist.\n\n  if (!fs.existsSync(parentPath)) fs.mkdirSync(parentPath, {\n    recursive: true\n  }); // Checks folder again and return a results.\n\n  return fs.existsSync(parentPath);\n};\n/**\r\n * Deletes a file.\r\n * @param {string} file - Path to the file to delete.\r\n * @param {Function} callback\r\n */\n\n\nconst deleteFile = (file, callback) => fs.unlink(file, callback);\n/**\r\n * Copy file via streams\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n */\n\n\nconst copyFile = (src, dst, callback) => {\n  // cbCalled flag and runCb helps to run cb only once.\n  let cbCalled = false;\n\n  let runCb = err => {\n    if (cbCalled) return;\n    cbCalled = true;\n    callback(err);\n  }; // Create read stream\n\n\n  let readable = fs.createReadStream(src);\n  readable.on('error', runCb); // Create write stream\n\n  let writable = fs.createWriteStream(dst);\n  writable.on('error', err => {\n    readable.destroy();\n    runCb(err);\n  });\n  writable.on('close', () => runCb()); // Copy file via piping streams.\n\n  readable.pipe(writable);\n};\n/**\r\n * moveFile: moves the file from src to dst.\r\n * Firstly trying to rename the file if no luck copying it to dst and then deleteing src.\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n * @param {Function} callback - A callback function.\r\n */\n\n\nconst moveFile = (src, dst, callback) => fs.rename(src, dst, err => err ? copyFile(src, dst, err => err ? callback(err) : deleteFile(src, callback)) : callback());\n/**\r\n * Save buffer data to a file.\r\n * @param {Buffer} buffer - buffer to save to a file.\r\n * @param {string} filePath - path to a file.\r\n */\n\n\nconst saveBufferToFile = (buffer, filePath, callback) => {\n  if (!Buffer.isBuffer(buffer)) {\n    return callback(new Error('buffer variable should be type of Buffer!'));\n  } // Setup readable stream from buffer.\n\n\n  let streamData = buffer;\n  let readStream = Readable();\n\n  readStream._read = () => {\n    readStream.push(streamData);\n    streamData = null;\n  }; // Setup file system writable stream.\n\n\n  let fstream = fs.createWriteStream(filePath); // console.log(\"Calling saveBuffer\");\n\n  fstream.on('error', err => {\n    // console.log(\"err cb\")\n    callback(err);\n  });\n  fstream.on('close', () => {\n    // console.log(\"close cb\");\n    callback();\n  }); // Copy file via piping streams.\n\n  readStream.pipe(fstream);\n};\n/**\r\n * Decodes uriEncoded file names.\r\n * @param fileName {String} - file name to decode.\r\n * @returns {String}\r\n */\n\n\nconst uriDecodeFileName = (opts, fileName) => {\n  return opts.uriDecodeFileNames ? decodeURIComponent(fileName) : fileName;\n};\n/**\r\n * Parses filename and extension and returns object {name, extension}.\r\n * @param {boolean|integer} preserveExtension - true/false or number of characters for extension.\r\n * @param {string} fileName - file name to parse.\r\n * @returns {Object} - { name, extension }.\r\n */\n\n\nconst parseFileNameExtension = (preserveExtension, fileName) => {\n  const preserveExtensionLength = parseInt(preserveExtension);\n  const result = {\n    name: fileName,\n    extension: ''\n  };\n  if (!preserveExtension && preserveExtensionLength !== 0) return result; // Define maximum extension length\n\n  const maxExtLength = isNaN(preserveExtensionLength) ? MAX_EXTENSION_LENGTH : Math.abs(preserveExtensionLength);\n  const nameParts = fileName.split('.');\n  if (nameParts.length < 2) return result;\n  let extension = nameParts.pop();\n\n  if (extension.length > maxExtLength && maxExtLength > 0) {\n    nameParts[nameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtLength);\n    extension = extension.substr(-maxExtLength);\n  }\n\n  result.extension = maxExtLength ? extension : '';\n  result.name = nameParts.join('.');\n  return result;\n};\n/**\r\n * Parse file name and extension.\r\n * @param {Object} opts - middleware options.\r\n * @param {string} fileName - Uploaded file name.\r\n * @returns {string}\r\n */\n\n\nconst parseFileName = (opts, fileName) => {\n  // Check fileName argument\n  if (!fileName || typeof fileName !== 'string') return getTempFilename(); // Cut off file name if it's lenght more then 255.\n\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255); // Decode file name if uriDecodeFileNames option set true.\n\n  parsedName = uriDecodeFileName(opts, parsedName); // Stop parsing file name if safeFileNames options hasn't been set.\n\n  if (!opts.safeFileNames) return parsedName; // Set regular expression for the file name.\n\n  const nameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp ? opts.safeFileNames : SAFE_FILE_NAME_REGEX; // Parse file name extension.\n\n  let {\n    name,\n    extension\n  } = parseFileNameExtension(opts.preserveExtension, parsedName);\n  if (extension.length) extension = '.' + extension.replace(nameRegex, '');\n  return name.replace(nameRegex, '').concat(extension);\n};\n\nmodule.exports = {\n  isFunc,\n  debugLog,\n  copyFile,\n  // For testing purpose.\n  moveFile,\n  errorFunc,\n  deleteFile,\n  // For testing purpose.\n  buildFields,\n  buildOptions,\n  parseFileName,\n  getTempFilename,\n  promiseCallback,\n  checkAndMakeDir,\n  saveBufferToFile,\n  uriDecodeFileName,\n  isSafeFromPollution\n};","map":{"version":3,"sources":["D:/Marcos Muni/Proyecto Muni/Gitinspecobras/inspecobras/client/node_modules/express-fileupload/lib/utilities.js"],"names":["fs","require","path","Readable","SAFE_FILE_NAME_REGEX","MAX_EXTENSION_LENGTH","TEMP_COUNTER_MAX","TEMP_PREFIX","tempCounter","debugLog","options","msg","opts","debug","console","log","getTempFilename","prefix","Date","now","isFunc","func","constructor","call","apply","errorFunc","resolve","reject","promiseCallback","hasFired","err","buildOptions","result","arguments","forEach","Object","keys","i","OBJECT_PROTOTYPE_KEYS","getOwnPropertyNames","prototype","ARRAY_PROTOTYPE_KEYS","Array","isSafeFromPollution","base","key","TOUCHES_ARRAY_PROTOTYPE","includes","TOUCHES_OBJECT_PROTOTYPE","buildFields","instance","field","value","undefined","create","push","checkAndMakeDir","fileUploadOptions","filePath","createParentPath","parentPath","dirname","existsSync","mkdirSync","recursive","deleteFile","file","callback","unlink","copyFile","src","dst","cbCalled","runCb","readable","createReadStream","on","writable","createWriteStream","destroy","pipe","moveFile","rename","saveBufferToFile","buffer","Buffer","isBuffer","Error","streamData","readStream","_read","fstream","uriDecodeFileName","fileName","uriDecodeFileNames","decodeURIComponent","parseFileNameExtension","preserveExtension","preserveExtensionLength","parseInt","name","extension","maxExtLength","isNaN","Math","abs","nameParts","split","length","pop","substr","join","parseFileName","parsedName","safeFileNames","nameRegex","RegExp","replace","concat","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAeF,OAAO,CAAC,QAAD,CAA5B,C,CAEA;;;AACA,MAAMG,oBAAoB,GAAG,SAA7B;AACA,MAAMC,oBAAoB,GAAG,CAA7B,C,CAEA;;AACA,MAAMC,gBAAgB,GAAG,KAAzB;AACA,MAAMC,WAAW,GAAG,KAApB;AACA,IAAIC,WAAW,GAAG,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAG,CAACC,OAAD,EAAUC,GAAV,KAAkB;AACjC,QAAMC,IAAI,GAAGF,OAAO,IAAI,EAAxB;AACA,MAAI,CAACE,IAAI,CAACC,KAAV,EAAiB,OAAO,KAAP;AACjBC,EAAAA,OAAO,CAACC,GAAR,CAAa,wBAAuBJ,GAAI,EAAxC,EAHiC,CAGW;;AAC5C,SAAO,IAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,eAAe,GAAG,YAA0B;AAAA,MAAzBC,MAAyB,uEAAhBV,WAAgB;AAChDC,EAAAA,WAAW,GAAGA,WAAW,IAAIF,gBAAf,GAAkC,CAAlC,GAAsCE,WAAW,GAAG,CAAlE;AACA,SAAQ,GAAES,MAAO,IAAGT,WAAY,IAAGU,IAAI,CAACC,GAAL,EAAW,EAA9C;AACD,CAHD;AAKA;AACA;AACA;AACA;;;AACA,MAAMC,MAAM,GAAGC,IAAI,IAAIA,IAAI,IAAIA,IAAI,CAACC,WAAb,IAA4BD,IAAI,CAACE,IAAjC,IAAyCF,IAAI,CAACG,KAA9C,GAAsD,IAAtD,GAA4D,KAAnF;AAEA;AACA;AACA;AACA;;;AACA,MAAMC,SAAS,GAAG,CAACC,OAAD,EAAUC,MAAV,KAAqBP,MAAM,CAACO,MAAD,CAAN,GAAiBA,MAAjB,GAA0BD,OAAjE;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAME,eAAe,GAAG,CAACF,OAAD,EAAUC,MAAV,KAAqB;AAC3C,MAAIE,QAAQ,GAAG,KAAf;AACA,SAAQC,GAAD,IAAS;AACd,QAAID,QAAJ,EAAc;AACZ;AACD;;AAEDA,IAAAA,QAAQ,GAAG,IAAX;AACA,WAAOC,GAAG,GAAGL,SAAS,CAACC,OAAD,EAAUC,MAAV,CAAT,CAA2BG,GAA3B,CAAH,GAAqCJ,OAAO,EAAtD;AACD,GAPD;AAQD,CAVD;AAYA;AACA;AACA;AACA;;;AACA,MAAMK,YAAY,GAAG,YAAW;AAC9B,QAAMC,MAAM,GAAG,EAAf;AACA,GAAC,GAAGC,SAAJ,EAAeC,OAAf,CAAuBxB,OAAO,IAAI;AAChC,QAAI,CAACA,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAAnC,EAA6C;AAC7CyB,IAAAA,MAAM,CAACC,IAAP,CAAY1B,OAAZ,EAAqBwB,OAArB,CAA6BG,CAAC,IAAIL,MAAM,CAACK,CAAD,CAAN,GAAY3B,OAAO,CAAC2B,CAAD,CAArD;AACD,GAHD;AAIA,SAAOL,MAAP;AACD,CAPD,C,CASA;AACA;;;AACA,MAAMM,qBAAqB,GAAGH,MAAM,CAACI,mBAAP,CAA2BJ,MAAM,CAACK,SAAlC,CAA9B;AACA,MAAMC,oBAAoB,GAAGN,MAAM,CAACI,mBAAP,CAA2BG,KAAK,CAACF,SAAjC,CAA7B;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMG,mBAAmB,GAAG,CAACC,IAAD,EAAOC,GAAP,KAAe;AACzC;AACA;AACA;AACA,QAAMC,uBAAuB,GAAIF,IAAI,YAAYF,KAAjB,IAA2BD,oBAAoB,CAACM,QAArB,CAA8BF,GAA9B,CAA3D;AACA,QAAMG,wBAAwB,GAAGV,qBAAqB,CAACS,QAAtB,CAA+BF,GAA/B,CAAjC;AAEA,SAAO,CAACC,uBAAD,IAA4B,CAACE,wBAApC;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAG,CAACC,QAAD,EAAWC,KAAX,EAAkBC,KAAlB,KAA4B;AAC9C;AACA,MAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKC,SAAhC,EAA2C,OAAOH,QAAP;AAC3CA,EAAAA,QAAQ,GAAGA,QAAQ,IAAIf,MAAM,CAACmB,MAAP,CAAc,IAAd,CAAvB;;AAEA,MAAI,CAACX,mBAAmB,CAACO,QAAD,EAAWC,KAAX,CAAxB,EAA2C;AACzC,WAAOD,QAAP;AACD,GAP6C,CAQ9C;;;AACA,MAAI,CAACA,QAAQ,CAACC,KAAD,CAAb,EAAsB;AACpBD,IAAAA,QAAQ,CAACC,KAAD,CAAR,GAAkBC,KAAlB;AACA,WAAOF,QAAP;AACD,GAZ6C,CAa9C;;;AACA,MAAIA,QAAQ,CAACC,KAAD,CAAR,YAA2BT,KAA/B,EAAsC;AACpCQ,IAAAA,QAAQ,CAACC,KAAD,CAAR,CAAgBI,IAAhB,CAAqBH,KAArB;AACD,GAFD,MAEO;AACLF,IAAAA,QAAQ,CAACC,KAAD,CAAR,GAAkB,CAACD,QAAQ,CAACC,KAAD,CAAT,EAAkBC,KAAlB,CAAlB;AACD;;AACD,SAAOF,QAAP;AACD,CApBD;AAsBA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,eAAe,GAAG,CAACC,iBAAD,EAAoBC,QAApB,KAAiC;AACvD;AACA,MAAI,CAACD,iBAAL,EAAwB,OAAO,KAAP;AACxB,MAAI,CAACA,iBAAiB,CAACE,gBAAvB,EAAyC,OAAO,KAAP,CAHc,CAIvD;;AACA,MAAI,CAACD,QAAL,EAAe,OAAO,KAAP;AACf,QAAME,UAAU,GAAG1D,IAAI,CAAC2D,OAAL,CAAaH,QAAb,CAAnB,CANuD,CAOvD;;AACA,MAAI,CAAC1D,EAAE,CAAC8D,UAAH,CAAcF,UAAd,CAAL,EAAgC5D,EAAE,CAAC+D,SAAH,CAAaH,UAAb,EAAyB;AAAEI,IAAAA,SAAS,EAAE;AAAb,GAAzB,EARuB,CASvD;;AACA,SAAOhE,EAAE,CAAC8D,UAAH,CAAcF,UAAd,CAAP;AACD,CAXD;AAaA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,UAAU,GAAG,CAACC,IAAD,EAAOC,QAAP,KAAoBnE,EAAE,CAACoE,MAAH,CAAUF,IAAV,EAAgBC,QAAhB,CAAvC;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAME,QAAQ,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWJ,QAAX,KAAwB;AACvC;AACA,MAAIK,QAAQ,GAAG,KAAf;;AACA,MAAIC,KAAK,GAAI3C,GAAD,IAAS;AACnB,QAAI0C,QAAJ,EAAc;AACdA,IAAAA,QAAQ,GAAG,IAAX;AACAL,IAAAA,QAAQ,CAACrC,GAAD,CAAR;AACD,GAJD,CAHuC,CAQvC;;;AACA,MAAI4C,QAAQ,GAAG1E,EAAE,CAAC2E,gBAAH,CAAoBL,GAApB,CAAf;AACAI,EAAAA,QAAQ,CAACE,EAAT,CAAY,OAAZ,EAAqBH,KAArB,EAVuC,CAWvC;;AACA,MAAII,QAAQ,GAAG7E,EAAE,CAAC8E,iBAAH,CAAqBP,GAArB,CAAf;AACAM,EAAAA,QAAQ,CAACD,EAAT,CAAY,OAAZ,EAAsB9C,GAAD,IAAO;AAC1B4C,IAAAA,QAAQ,CAACK,OAAT;AACAN,IAAAA,KAAK,CAAC3C,GAAD,CAAL;AACD,GAHD;AAIA+C,EAAAA,QAAQ,CAACD,EAAT,CAAY,OAAZ,EAAqB,MAAMH,KAAK,EAAhC,EAjBuC,CAkBvC;;AACAC,EAAAA,QAAQ,CAACM,IAAT,CAAcH,QAAd;AACD,CApBD;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,QAAQ,GAAG,CAACX,GAAD,EAAMC,GAAN,EAAWJ,QAAX,KAAwBnE,EAAE,CAACkF,MAAH,CAAUZ,GAAV,EAAeC,GAAf,EAAoBzC,GAAG,IAAKA,GAAG,GACpEuC,QAAQ,CAACC,GAAD,EAAMC,GAAN,EAAWzC,GAAG,IAAIA,GAAG,GAAGqC,QAAQ,CAACrC,GAAD,CAAX,GAAmBmC,UAAU,CAACK,GAAD,EAAMH,QAAN,CAAlD,CAD4D,GAEpEA,QAAQ,EAF6B,CAAzC;AAKA;AACA;AACA;AACA;AACA;;;AACA,MAAMgB,gBAAgB,GAAG,CAACC,MAAD,EAAS1B,QAAT,EAAmBS,QAAnB,KAAgC;AACvD,MAAI,CAACkB,MAAM,CAACC,QAAP,CAAgBF,MAAhB,CAAL,EAA8B;AAC5B,WAAOjB,QAAQ,CAAC,IAAIoB,KAAJ,CAAU,2CAAV,CAAD,CAAf;AACD,GAHsD,CAIvD;;;AACA,MAAIC,UAAU,GAAGJ,MAAjB;AACA,MAAIK,UAAU,GAAGtF,QAAQ,EAAzB;;AACAsF,EAAAA,UAAU,CAACC,KAAX,GAAmB,MAAM;AACvBD,IAAAA,UAAU,CAAClC,IAAX,CAAgBiC,UAAhB;AACAA,IAAAA,UAAU,GAAG,IAAb;AACD,GAHD,CAPuD,CAWvD;;;AACA,MAAIG,OAAO,GAAG3F,EAAE,CAAC8E,iBAAH,CAAqBpB,QAArB,CAAd,CAZuD,CAavD;;AACAiC,EAAAA,OAAO,CAACf,EAAR,CAAW,OAAX,EAAoB9C,GAAG,IAAI;AACzB;AACAqC,IAAAA,QAAQ,CAACrC,GAAD,CAAR;AACD,GAHD;AAIA6D,EAAAA,OAAO,CAACf,EAAR,CAAW,OAAX,EAAoB,MAAM;AACxB;AACAT,IAAAA,QAAQ;AACT,GAHD,EAlBuD,CAsBvD;;AACAsB,EAAAA,UAAU,CAACT,IAAX,CAAgBW,OAAhB;AACD,CAxBD;AA0BA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,iBAAiB,GAAG,CAAChF,IAAD,EAAOiF,QAAP,KAAoB;AAC5C,SAAOjF,IAAI,CAACkF,kBAAL,GAA0BC,kBAAkB,CAACF,QAAD,CAA5C,GAAyDA,QAAhE;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,sBAAsB,GAAG,CAACC,iBAAD,EAAoBJ,QAApB,KAAiC;AAC9D,QAAMK,uBAAuB,GAAGC,QAAQ,CAACF,iBAAD,CAAxC;AACA,QAAMjE,MAAM,GAAG;AAACoE,IAAAA,IAAI,EAAEP,QAAP;AAAiBQ,IAAAA,SAAS,EAAE;AAA5B,GAAf;AACA,MAAI,CAACJ,iBAAD,IAAsBC,uBAAuB,KAAK,CAAtD,EAAyD,OAAOlE,MAAP,CAHK,CAI9D;;AACA,QAAMsE,YAAY,GAAGC,KAAK,CAACL,uBAAD,CAAL,GACjB7F,oBADiB,GAEjBmG,IAAI,CAACC,GAAL,CAASP,uBAAT,CAFJ;AAIA,QAAMQ,SAAS,GAAGb,QAAQ,CAACc,KAAT,CAAe,GAAf,CAAlB;AACA,MAAID,SAAS,CAACE,MAAV,GAAmB,CAAvB,EAA0B,OAAO5E,MAAP;AAE1B,MAAIqE,SAAS,GAAGK,SAAS,CAACG,GAAV,EAAhB;;AACA,MACER,SAAS,CAACO,MAAV,GAAmBN,YAAnB,IACAA,YAAY,GAAG,CAFjB,EAGE;AACAI,IAAAA,SAAS,CAACA,SAAS,CAACE,MAAV,GAAmB,CAApB,CAAT,IACE,MACAP,SAAS,CAACS,MAAV,CAAiB,CAAjB,EAAoBT,SAAS,CAACO,MAAV,GAAmBN,YAAvC,CAFF;AAGAD,IAAAA,SAAS,GAAGA,SAAS,CAACS,MAAV,CAAiB,CAACR,YAAlB,CAAZ;AACD;;AAEDtE,EAAAA,MAAM,CAACqE,SAAP,GAAmBC,YAAY,GAAGD,SAAH,GAAe,EAA9C;AACArE,EAAAA,MAAM,CAACoE,IAAP,GAAcM,SAAS,CAACK,IAAV,CAAe,GAAf,CAAd;AACA,SAAO/E,MAAP;AACD,CA1BD;AA4BA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgF,aAAa,GAAG,CAACpG,IAAD,EAAOiF,QAAP,KAAoB;AACxC;AACA,MAAI,CAACA,QAAD,IAAa,OAAOA,QAAP,KAAoB,QAArC,EAA+C,OAAO7E,eAAe,EAAtB,CAFP,CAGxC;;AACA,MAAIiG,UAAU,GAAGpB,QAAQ,CAACe,MAAT,IAAmB,GAAnB,GAAyBf,QAAzB,GAAoCA,QAAQ,CAACiB,MAAT,CAAgB,CAAhB,EAAmB,GAAnB,CAArD,CAJwC,CAKxC;;AACAG,EAAAA,UAAU,GAAGrB,iBAAiB,CAAChF,IAAD,EAAOqG,UAAP,CAA9B,CANwC,CAOxC;;AACA,MAAI,CAACrG,IAAI,CAACsG,aAAV,EAAyB,OAAOD,UAAP,CARe,CASxC;;AACA,QAAME,SAAS,GAAG,OAAOvG,IAAI,CAACsG,aAAZ,KAA8B,QAA9B,IAA0CtG,IAAI,CAACsG,aAAL,YAA8BE,MAAxE,GACdxG,IAAI,CAACsG,aADS,GAEd9G,oBAFJ,CAVwC,CAaxC;;AACA,MAAI;AAACgG,IAAAA,IAAD;AAAOC,IAAAA;AAAP,MAAoBL,sBAAsB,CAACpF,IAAI,CAACqF,iBAAN,EAAyBgB,UAAzB,CAA9C;AACA,MAAIZ,SAAS,CAACO,MAAd,EAAsBP,SAAS,GAAG,MAAMA,SAAS,CAACgB,OAAV,CAAkBF,SAAlB,EAA6B,EAA7B,CAAlB;AAEtB,SAAOf,IAAI,CAACiB,OAAL,CAAaF,SAAb,EAAwB,EAAxB,EAA4BG,MAA5B,CAAmCjB,SAAnC,CAAP;AACD,CAlBD;;AAoBAkB,MAAM,CAACC,OAAP,GAAiB;AACfpG,EAAAA,MADe;AAEfX,EAAAA,QAFe;AAGf4D,EAAAA,QAHe;AAGL;AACVY,EAAAA,QAJe;AAKfxD,EAAAA,SALe;AAMfwC,EAAAA,UANe;AAMH;AACZhB,EAAAA,WAPe;AAQflB,EAAAA,YARe;AASfiF,EAAAA,aATe;AAUfhG,EAAAA,eAVe;AAWfY,EAAAA,eAXe;AAYf4B,EAAAA,eAZe;AAaf2B,EAAAA,gBAbe;AAcfS,EAAAA,iBAde;AAefjD,EAAAA;AAfe,CAAjB","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { Readable } = require('stream');\r\n\r\n// Parameters for safe file name parsing.\r\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g;\r\nconst MAX_EXTENSION_LENGTH = 3;\r\n\r\n// Parameters to generate unique temporary file names:\r\nconst TEMP_COUNTER_MAX = 65536;\r\nconst TEMP_PREFIX = 'tmp';\r\nlet tempCounter = 0;\r\n\r\n/**\r\n * Logs message to console if debug option set to true.\r\n * @param {Object} options - options object.\r\n * @param {string} msg - message to log.\r\n * @returns {boolean} - false if debug is off.\r\n */\r\nconst debugLog = (options, msg) => {\r\n  const opts = options || {};\r\n  if (!opts.debug) return false;\r\n  console.log(`Express-file-upload: ${msg}`); // eslint-disable-line\r\n  return true;\r\n};\r\n\r\n/**\r\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\r\n * @param {string} prefix - a prefix for generated unique file name.\r\n * @returns {string}\r\n */\r\nconst getTempFilename = (prefix = TEMP_PREFIX) => {\r\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;\r\n  return `${prefix}-${tempCounter}-${Date.now()}`;\r\n};\r\n\r\n/**\r\n * isFunc: Checks if argument is a function.\r\n * @returns {boolean} - Returns true if argument is a function.\r\n */\r\nconst isFunc = func => func && func.constructor && func.call && func.apply ? true: false;\r\n\r\n/**\r\n * Set errorFunc to the same value as successFunc for callback mode.\r\n * @returns {Function}\r\n */\r\nconst errorFunc = (resolve, reject) => isFunc(reject) ? reject : resolve;\r\n\r\n/**\r\n * Return a callback function for promise resole/reject args.\r\n * Ensures that callback is called only once.\r\n * @returns {Function}\r\n */\r\nconst promiseCallback = (resolve, reject) => {\r\n  let hasFired = false;\r\n  return (err) => {\r\n    if (hasFired) {\r\n      return;\r\n    }\r\n\r\n    hasFired = true;\r\n    return err ? errorFunc(resolve, reject)(err) : resolve();\r\n  };\r\n};\r\n\r\n/**\r\n * Builds instance options from arguments objects(can't be arrow function).\r\n * @returns {Object} - result options.\r\n */\r\nconst buildOptions = function() {\r\n  const result = {};\r\n  [...arguments].forEach(options => {\r\n    if (!options || typeof options !== 'object') return;\r\n    Object.keys(options).forEach(i => result[i] = options[i]);\r\n  });\r\n  return result;\r\n};\r\n\r\n// The default prototypes for both objects and arrays.\r\n// Used by isSafeFromPollution\r\nconst OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype);\r\nconst ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype);\r\n\r\n/**\r\n * Determines whether a key insertion into an object could result in a prototype pollution\r\n * @param {Object} base - The object whose insertion we are checking\r\n * @param {string} key - The key that will be inserted\r\n */\r\nconst isSafeFromPollution = (base, key) => {\r\n  // We perform an instanceof check instead of Array.isArray as the former is more\r\n  // permissive for cases in which the object as an Array prototype but was not constructed\r\n  // via an Array constructor or literal.\r\n  const TOUCHES_ARRAY_PROTOTYPE = (base instanceof Array) && ARRAY_PROTOTYPE_KEYS.includes(key);\r\n  const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key);\r\n\r\n  return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE;\r\n};\r\n\r\n/**\r\n * Builds request fields (using to build req.body and req.files)\r\n * @param {Object} instance - request object.\r\n * @param {string} field - field name.\r\n * @param {any} value - field value.\r\n * @returns {Object}\r\n */\r\nconst buildFields = (instance, field, value) => {\r\n  // Do nothing if value is not set.\r\n  if (value === null || value === undefined) return instance;\r\n  instance = instance || Object.create(null);\r\n\r\n  if (!isSafeFromPollution(instance, field)) {\r\n    return instance;\r\n  }\r\n  // Non-array fields\r\n  if (!instance[field]) {\r\n    instance[field] = value;\r\n    return instance;\r\n  }\r\n  // Array fields\r\n  if (instance[field] instanceof Array) {\r\n    instance[field].push(value);\r\n  } else {\r\n    instance[field] = [instance[field], value];\r\n  }\r\n  return instance;\r\n};\r\n\r\n/**\r\n * Creates a folder for file specified in the path variable\r\n * @param {Object} fileUploadOptions\r\n * @param {string} filePath\r\n * @returns {boolean}\r\n */\r\nconst checkAndMakeDir = (fileUploadOptions, filePath) => {\r\n  // Check upload options were set.\r\n  if (!fileUploadOptions) return false;\r\n  if (!fileUploadOptions.createParentPath) return false;\r\n  // Check whether folder for the file exists.\r\n  if (!filePath) return false;\r\n  const parentPath = path.dirname(filePath);\r\n  // Create folder if it doesn't exist.\r\n  if (!fs.existsSync(parentPath)) fs.mkdirSync(parentPath, { recursive: true });\r\n  // Checks folder again and return a results.\r\n  return fs.existsSync(parentPath);\r\n};\r\n\r\n/**\r\n * Deletes a file.\r\n * @param {string} file - Path to the file to delete.\r\n * @param {Function} callback\r\n */\r\nconst deleteFile = (file, callback) => fs.unlink(file, callback);\r\n\r\n/**\r\n * Copy file via streams\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n */\r\nconst copyFile = (src, dst, callback) => {\r\n  // cbCalled flag and runCb helps to run cb only once.\r\n  let cbCalled = false;\r\n  let runCb = (err) => {\r\n    if (cbCalled) return;\r\n    cbCalled = true;\r\n    callback(err);\r\n  };\r\n  // Create read stream\r\n  let readable = fs.createReadStream(src);\r\n  readable.on('error', runCb);\r\n  // Create write stream\r\n  let writable = fs.createWriteStream(dst);\r\n  writable.on('error', (err)=>{\r\n    readable.destroy();\r\n    runCb(err);\r\n  });\r\n  writable.on('close', () => runCb());\r\n  // Copy file via piping streams.\r\n  readable.pipe(writable);\r\n};\r\n\r\n/**\r\n * moveFile: moves the file from src to dst.\r\n * Firstly trying to rename the file if no luck copying it to dst and then deleteing src.\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n * @param {Function} callback - A callback function.\r\n */\r\nconst moveFile = (src, dst, callback) => fs.rename(src, dst, err => (err\r\n  ? copyFile(src, dst, err => err ? callback(err) : deleteFile(src, callback))\r\n  : callback()\r\n));\r\n\r\n/**\r\n * Save buffer data to a file.\r\n * @param {Buffer} buffer - buffer to save to a file.\r\n * @param {string} filePath - path to a file.\r\n */\r\nconst saveBufferToFile = (buffer, filePath, callback) => {\r\n  if (!Buffer.isBuffer(buffer)) {\r\n    return callback(new Error('buffer variable should be type of Buffer!'));\r\n  }\r\n  // Setup readable stream from buffer.\r\n  let streamData = buffer;\r\n  let readStream = Readable();\r\n  readStream._read = () => {\r\n    readStream.push(streamData);\r\n    streamData = null;\r\n  };\r\n  // Setup file system writable stream.\r\n  let fstream = fs.createWriteStream(filePath);\r\n  // console.log(\"Calling saveBuffer\");\r\n  fstream.on('error', err => {\r\n    // console.log(\"err cb\")\r\n    callback(err);\r\n  });\r\n  fstream.on('close', () => {\r\n    // console.log(\"close cb\");\r\n    callback();\r\n  });\r\n  // Copy file via piping streams.\r\n  readStream.pipe(fstream);\r\n};\r\n\r\n/**\r\n * Decodes uriEncoded file names.\r\n * @param fileName {String} - file name to decode.\r\n * @returns {String}\r\n */\r\nconst uriDecodeFileName = (opts, fileName) => {\r\n  return opts.uriDecodeFileNames ? decodeURIComponent(fileName) : fileName;\r\n};\r\n\r\n/**\r\n * Parses filename and extension and returns object {name, extension}.\r\n * @param {boolean|integer} preserveExtension - true/false or number of characters for extension.\r\n * @param {string} fileName - file name to parse.\r\n * @returns {Object} - { name, extension }.\r\n */\r\nconst parseFileNameExtension = (preserveExtension, fileName) => {\r\n  const preserveExtensionLength = parseInt(preserveExtension);\r\n  const result = {name: fileName, extension: ''};\r\n  if (!preserveExtension && preserveExtensionLength !== 0) return result;\r\n  // Define maximum extension length\r\n  const maxExtLength = isNaN(preserveExtensionLength)\r\n    ? MAX_EXTENSION_LENGTH\r\n    : Math.abs(preserveExtensionLength);\r\n\r\n  const nameParts = fileName.split('.');\r\n  if (nameParts.length < 2) return result;\r\n\r\n  let extension = nameParts.pop();\r\n  if (\r\n    extension.length > maxExtLength &&\r\n    maxExtLength > 0\r\n  ) {\r\n    nameParts[nameParts.length - 1] +=\r\n      '.' +\r\n      extension.substr(0, extension.length - maxExtLength);\r\n    extension = extension.substr(-maxExtLength);\r\n  }\r\n\r\n  result.extension = maxExtLength ? extension : '';\r\n  result.name = nameParts.join('.');\r\n  return result;\r\n};\r\n\r\n/**\r\n * Parse file name and extension.\r\n * @param {Object} opts - middleware options.\r\n * @param {string} fileName - Uploaded file name.\r\n * @returns {string}\r\n */\r\nconst parseFileName = (opts, fileName) => {\r\n  // Check fileName argument\r\n  if (!fileName || typeof fileName !== 'string') return getTempFilename();\r\n  // Cut off file name if it's lenght more then 255.\r\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255);\r\n  // Decode file name if uriDecodeFileNames option set true.\r\n  parsedName = uriDecodeFileName(opts, parsedName);\r\n  // Stop parsing file name if safeFileNames options hasn't been set.\r\n  if (!opts.safeFileNames) return parsedName;\r\n  // Set regular expression for the file name.\r\n  const nameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp\r\n    ? opts.safeFileNames\r\n    : SAFE_FILE_NAME_REGEX;\r\n  // Parse file name extension.\r\n  let {name, extension} = parseFileNameExtension(opts.preserveExtension, parsedName);\r\n  if (extension.length) extension = '.' + extension.replace(nameRegex, '');\r\n\r\n  return name.replace(nameRegex, '').concat(extension);\r\n};\r\n\r\nmodule.exports = {\r\n  isFunc,\r\n  debugLog,\r\n  copyFile, // For testing purpose.\r\n  moveFile,\r\n  errorFunc,\r\n  deleteFile, // For testing purpose.\r\n  buildFields,\r\n  buildOptions,\r\n  parseFileName,\r\n  getTempFilename,\r\n  promiseCallback,\r\n  checkAndMakeDir,\r\n  saveBufferToFile,\r\n  uriDecodeFileName,\r\n  isSafeFromPollution\r\n};\r\n"]},"metadata":{},"sourceType":"script"}