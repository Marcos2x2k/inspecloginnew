{"ast":null,"code":"const Busboy = require('busboy');\n\nconst UploadTimer = require('./uploadtimer');\n\nconst fileFactory = require('./fileFactory');\n\nconst memHandler = require('./memHandler');\n\nconst tempFileHandler = require('./tempFileHandler');\n\nconst processNested = require('./processNested');\n\nconst {\n  isFunc,\n  debugLog,\n  buildFields,\n  buildOptions,\n  parseFileName\n} = require('./utilities');\n\nconst waitFlushProperty = Symbol('wait flush property symbol');\n/**\n * Processes multipart request\n * Builds a req.body object for fields\n * Builds a req.files object for files\n * @param  {Object}   options expressFileupload and Busboy options\n * @param  {Object}   req     Express request object\n * @param  {Object}   res     Express response object\n * @param  {Function} next    Express next method\n * @return {void}\n */\n\nmodule.exports = (options, req, res, next) => {\n  req.files = null; // Build busboy options and init busboy instance.\n\n  const busboyOptions = buildOptions(options, {\n    headers: req.headers\n  });\n  const busboy = Busboy(busboyOptions); // Close connection with specified reason and http code, default: 400 Bad Request.\n\n  const closeConnection = (code, reason) => {\n    req.unpipe(busboy);\n    res.writeHead(code || 400, {\n      Connection: 'close'\n    });\n    res.end(reason || 'Bad Request');\n  }; // Express proxies sometimes attach multipart data to a buffer\n\n\n  if (req.body instanceof Buffer) {\n    req.body = Object.create(null);\n  } // Build multipart req.body fields\n\n\n  busboy.on('field', (field, val) => req.body = buildFields(req.body, field, val)); // Build req.files fields\n\n  busboy.on('file', (field, file, info) => {\n    // Parse file name(cutting huge names, decoding, etc..).\n    const {\n      filename: name,\n      encoding,\n      mimeType: mime\n    } = info;\n    const filename = parseFileName(options, name); // Define methods and handlers for upload process.\n\n    const {\n      dataHandler,\n      getFilePath,\n      getFileSize,\n      getHash,\n      complete,\n      cleanup,\n      getWritePromise\n    } = options.useTempFiles ? tempFileHandler(options, field, filename) // Upload into temporary file.\n    : memHandler(options, field, filename); // Upload into RAM.\n\n    const writePromise = options.useTempFiles ? getWritePromise().catch(err => {\n      req.unpipe(busboy);\n      req.resume();\n      cleanup();\n      next(err);\n    }) : getWritePromise(); // Define upload timer.\n\n    const uploadTimer = new UploadTimer(options.uploadTimeout, () => {\n      file.removeAllListeners('data');\n      file.resume(); // After destroy an error event will be emitted and file clean up will be done.\n\n      file.destroy(new Error(`Upload timeout ${field}->${filename}, bytes:${getFileSize()}`));\n    });\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`); // Reset upload timer in case of file limit reached.\n\n      uploadTimer.clear(); // Run a user defined limit handler if it has been set.\n\n      if (isFunc(options.limitHandler)) return options.limitHandler(req, res, next); // Close connection with 413 code and do cleanup if abortOnLimit set(default: false).\n\n      if (options.abortOnLimit) {\n        debugLog(options, `Aborting upload because of size limit ${field}->${filename}.`);\n        !isFunc(options.limitHandler) ? closeConnection(413, options.responseOnLimit) : '';\n        cleanup();\n      }\n    });\n    file.on('data', data => {\n      uploadTimer.set(); // Refresh upload timer each time new data chunk came.\n\n      dataHandler(data); // Handle new piece of data.\n    });\n    file.on('end', () => {\n      const size = getFileSize(); // Debug logging for file upload ending.\n\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`); // Reset upload timer in case of end event.\n\n      uploadTimer.clear(); // See https://github.com/richardgirges/express-fileupload/issues/191\n      // Do not add file instance to the req.files if original name and size are empty.\n      // Empty name and zero size indicates empty file field in the posted form.\n\n      if (!name && size === 0) {\n        if (options.useTempFiles) {\n          cleanup();\n          debugLog(options, `Removing the empty file ${field}->${filename}`);\n        }\n\n        return debugLog(options, `Don't add file instance if original name and size are empty`);\n      }\n\n      req.files = buildFields(req.files, field, fileFactory({\n        buffer: complete(),\n        name: filename,\n        tempFilePath: getFilePath(),\n        hash: getHash(),\n        size,\n        encoding,\n        truncated: file.truncated,\n        mimetype: mime\n      }, options));\n\n      if (!req[waitFlushProperty]) {\n        req[waitFlushProperty] = [];\n      }\n\n      req[waitFlushProperty].push(writePromise);\n    });\n    file.on('error', err => {\n      uploadTimer.clear(); // Reset upload timer in case of errors.\n\n      debugLog(options, err);\n      cleanup();\n      next();\n    }); // Debug logging for a new file upload.\n\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`); // Set new upload timeout for a new file.\n\n    uploadTimer.set();\n  });\n  busboy.on('finish', () => {\n    debugLog(options, `Busboy finished parsing request.`);\n\n    if (options.parseNested) {\n      req.body = processNested(req.body);\n      req.files = processNested(req.files);\n    }\n\n    if (!req[waitFlushProperty]) return next();\n    Promise.all(req[waitFlushProperty]).then(() => {\n      delete req[waitFlushProperty];\n      next();\n    });\n  });\n  busboy.on('error', err => {\n    debugLog(options, `Busboy error`);\n    next(err);\n  });\n  req.pipe(busboy);\n};","map":{"version":3,"sources":["D:/Marcos Muni/Proyecto Muni/Gitinspecobras/inspecobras/client/node_modules/express-fileupload/lib/processMultipart.js"],"names":["Busboy","require","UploadTimer","fileFactory","memHandler","tempFileHandler","processNested","isFunc","debugLog","buildFields","buildOptions","parseFileName","waitFlushProperty","Symbol","module","exports","options","req","res","next","files","busboyOptions","headers","busboy","closeConnection","code","reason","unpipe","writeHead","Connection","end","body","Buffer","Object","create","on","field","val","file","info","filename","name","encoding","mimeType","mime","dataHandler","getFilePath","getFileSize","getHash","complete","cleanup","getWritePromise","useTempFiles","writePromise","catch","err","resume","uploadTimer","uploadTimeout","removeAllListeners","destroy","Error","clear","limitHandler","abortOnLimit","responseOnLimit","data","set","size","buffer","tempFilePath","hash","truncated","mimetype","push","parseNested","Promise","all","then","pipe"],"mappings":"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","sourcesContent":["const Busboy = require('busboy');\nconst UploadTimer = require('./uploadtimer');\nconst fileFactory = require('./fileFactory');\nconst memHandler = require('./memHandler');\nconst tempFileHandler = require('./tempFileHandler');\nconst processNested = require('./processNested');\nconst {\n  isFunc,\n  debugLog,\n  buildFields,\n  buildOptions,\n  parseFileName\n} = require('./utilities');\n\nconst waitFlushProperty = Symbol('wait flush property symbol');\n\n/**\n * Processes multipart request\n * Builds a req.body object for fields\n * Builds a req.files object for files\n * @param  {Object}   options expressFileupload and Busboy options\n * @param  {Object}   req     Express request object\n * @param  {Object}   res     Express response object\n * @param  {Function} next    Express next method\n * @return {void}\n */\nmodule.exports = (options, req, res, next) => {\n  req.files = null;\n\n  // Build busboy options and init busboy instance.\n  const busboyOptions = buildOptions(options, { headers: req.headers });\n  const busboy = Busboy(busboyOptions);\n\n  // Close connection with specified reason and http code, default: 400 Bad Request.\n  const closeConnection = (code, reason) => {\n    req.unpipe(busboy);\n    res.writeHead(code || 400, { Connection: 'close' });\n    res.end(reason || 'Bad Request');\n  };\n\n  // Express proxies sometimes attach multipart data to a buffer\n  if (req.body instanceof Buffer) {\n    req.body = Object.create(null);\n  }\n  // Build multipart req.body fields\n  busboy.on('field', (field, val) => req.body = buildFields(req.body, field, val));\n\n  // Build req.files fields\n  busboy.on('file', (field, file, info) => {\n    // Parse file name(cutting huge names, decoding, etc..).\n    const {filename:name, encoding, mimeType: mime} = info;\n    const filename = parseFileName(options, name);\n    // Define methods and handlers for upload process.\n    const {\n      dataHandler,\n      getFilePath,\n      getFileSize,\n      getHash,\n      complete,\n      cleanup,\n      getWritePromise\n    } = options.useTempFiles\n      ? tempFileHandler(options, field, filename) // Upload into temporary file.\n      : memHandler(options, field, filename);     // Upload into RAM.\n\n    const writePromise = options.useTempFiles\n      ? getWritePromise().catch(err => {\n        req.unpipe(busboy);\n        req.resume();\n        cleanup();\n        next(err);\n      }) : getWritePromise();\n\n    // Define upload timer.\n    const uploadTimer = new UploadTimer(options.uploadTimeout, () => {\n      file.removeAllListeners('data');\n      file.resume();\n      // After destroy an error event will be emitted and file clean up will be done.\n      file.destroy(new Error(`Upload timeout ${field}->${filename}, bytes:${getFileSize()}`));\n    });\n\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`);\n      // Reset upload timer in case of file limit reached.\n      uploadTimer.clear();\n      // Run a user defined limit handler if it has been set.\n      if (isFunc(options.limitHandler)) return options.limitHandler(req, res, next);\n      // Close connection with 413 code and do cleanup if abortOnLimit set(default: false).\n      if (options.abortOnLimit) {\n        debugLog(options, `Aborting upload because of size limit ${field}->${filename}.`);\n        !isFunc(options.limitHandler) ? closeConnection(413, options.responseOnLimit) : '';\n        cleanup();\n      }\n    });\n\n    file.on('data', (data) => {\n      uploadTimer.set(); // Refresh upload timer each time new data chunk came.\n      dataHandler(data); // Handle new piece of data.\n    });\n\n    file.on('end', () => {\n      const size = getFileSize();\n      // Debug logging for file upload ending.\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`);\n      // Reset upload timer in case of end event.\n      uploadTimer.clear();\n      // See https://github.com/richardgirges/express-fileupload/issues/191\n      // Do not add file instance to the req.files if original name and size are empty.\n      // Empty name and zero size indicates empty file field in the posted form.\n      if (!name && size === 0) {\n        if (options.useTempFiles) {\n          cleanup();\n          debugLog(options, `Removing the empty file ${field}->${filename}`);\n        }\n        return debugLog(options, `Don't add file instance if original name and size are empty`);\n      }\n      req.files = buildFields(req.files, field, fileFactory({\n        buffer: complete(),\n        name: filename,\n        tempFilePath: getFilePath(),\n        hash: getHash(),\n        size,\n        encoding,\n        truncated: file.truncated,\n        mimetype: mime\n      }, options));\n\n      if (!req[waitFlushProperty]) {\n        req[waitFlushProperty] = [];\n      }\n      req[waitFlushProperty].push(writePromise);\n    });\n\n    file.on('error', (err) => {\n      uploadTimer.clear(); // Reset upload timer in case of errors.\n      debugLog(options, err);\n      cleanup();\n      next();\n    });\n\n    // Debug logging for a new file upload.\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`);\n    // Set new upload timeout for a new file.\n    uploadTimer.set();\n  });\n\n  busboy.on('finish', () => {\n    debugLog(options, `Busboy finished parsing request.`);\n    if (options.parseNested) {\n      req.body = processNested(req.body);\n      req.files = processNested(req.files);\n    }\n\n    if (!req[waitFlushProperty]) return next();\n    Promise.all(req[waitFlushProperty])\n      .then(() => {\n        delete req[waitFlushProperty];\n        next();\n      });\n  });\n\n  busboy.on('error', (err) => {\n    debugLog(options, `Busboy error`);\n    next(err);\n  });\n\n  req.pipe(busboy);\n};\n"]},"metadata":{},"sourceType":"script"}