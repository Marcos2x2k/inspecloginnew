{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst is = require('./is');\n\nrequire('./libvips').hasVendoredLibvips();\n\nrequire('./sharp'); // Use NODE_DEBUG=sharp to enable libvips warnings\n\n\nconst debuglog = util.debuglog('sharp');\n/**\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG, WebP, GIF, AVIF or TIFF format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Non-critical problems encountered during processing are emitted as `warning` events.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * @constructs Sharp\n *\n * @emits Sharp#info\n * @emits Sharp#warning\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from readableStream,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * var transformer = sharp()\n *   .resize(300)\n *   .on('info', function(info) {\n *     console.log('Image height is ' + info.height);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-transluent red pixels\n * sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @example\n * // Convert an animated GIF to an animated WebP\n * await sharp('in.gif', { animated: true }).toFile('out.webp');\n *\n * @example\n * // Read a raw array of pixels and save it to a png\n * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray\n * const image = sharp(input, {\n *   // because the input does not contain its dimensions or how many channels it has\n *   // we need to specify it in the constructor options\n *   raw: {\n *     width: 2,\n *     height: 1,\n *     channels: 3\n *   }\n * });\n * await image.toFile('my-two-pixels.png');\n *\n * @example\n * // Generate RGB Gaussian noise\n * await sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 3,\n *     noise: {\n *       type: 'gaussian',\n *       mean: 128,\n *       sigma: 30\n *     }\n *  }\n * }).toFile('noise.png');\n *\n * @param {(Buffer|Uint8Array|Uint8ClampedArray|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|string)} [input] - if present, can be\n *  a Buffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image data, or\n *  a TypedArray containing raw pixel image data, or\n *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.\n *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string} [options.failOn='warning'] - level of sensitivity to invalid images, one of (in order of sensitivity): 'none' (least), 'truncated', 'error' or 'warning' (most), highers level imply lower levels.\n * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels\n *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.\n *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).\n * @param {boolean} [options.unlimited=false] - Set this to `true` to remove safety features that help prevent memory exhaustion (SVG, PNG).\n * @param {boolean} [options.sequentialRead=false] - Set this to `true` to use sequential rather than random access where possible.\n *  This can reduce memory usage and might improve performance on some systems.\n * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.\n * @param {number} [options.pages=1] - number of pages to extract for multi-page input (GIF, WebP, AVIF, TIFF, PDF), use -1 for all pages.\n * @param {number} [options.page=0] - page number to start extracting from for multi-page input (GIF, WebP, AVIF, TIFF, PDF), zero based.\n * @param {number} [options.subifd=-1] - subIFD (Sub Image File Directory) to extract for OME-TIFF, defaults to main image.\n * @param {number} [options.level=0] - level to extract from a multi-level input (OpenSlide), zero based.\n * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (equivalent of setting `pages` to `-1`).\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {number} [options.raw.width] - integral number of pixels wide.\n * @param {number} [options.raw.height] - integral number of pixels high.\n * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.\n * @param {boolean} [options.raw.premultiplied] - specifies that the raw input has already been premultiplied, set to `true`\n *  to avoid sharp premultiplying the image. (optional, default `false`)\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {number} [options.create.width] - integral number of pixels wide.\n * @param {number} [options.create.height] - integral number of pixels high.\n * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).\n * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [options.create.noise] - describes a noise to be created.\n * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.\n * @param {number} [options.create.noise.mean] - mean of pixels in generated noise.\n * @param {number} [options.create.noise.sigma] - standard deviation of pixels in generated noise.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\nconst Sharp = function (input, options) {\n  if (arguments.length === 1 && !is.defined(input)) {\n    throw new Error('Invalid input');\n  }\n\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n\n  stream.Duplex.call(this);\n  this.options = {\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    position: 0,\n    resizeBackground: [0, 0, 0, 255],\n    useExifOrientation: false,\n    angle: 0,\n    rotationAngle: 0,\n    rotationBackground: [0, 0, 0, 255],\n    rotateBeforePreExtract: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    extendBackground: [0, 0, 0, 255],\n    withoutEnlargement: false,\n    withoutReduction: false,\n    affineMatrix: [],\n    affineBackground: [0, 0, 0, 255],\n    affineIdx: 0,\n    affineIdy: 0,\n    affineOdx: 0,\n    affineOdy: 0,\n    affineInterpolator: this.constructor.interpolators.bilinear,\n    kernel: 'lanczos3',\n    fastShrinkOnLoad: true,\n    // operations\n    tintA: 128,\n    tintB: 128,\n    flatten: false,\n    flattenBackground: [0, 0, 0],\n    negate: false,\n    negateAlpha: true,\n    medianSize: 0,\n    blurSigma: 0,\n    sharpenSigma: 0,\n    sharpenM1: 1,\n    sharpenM2: 2,\n    sharpenX1: 2,\n    sharpenY2: 10,\n    sharpenY3: 20,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimThreshold: 0,\n    gamma: 0,\n    gammaOut: 0,\n    greyscale: false,\n    normalise: false,\n    claheWidth: 0,\n    claheHeight: 0,\n    claheMaxSlope: 3,\n    brightness: 1,\n    saturation: 1,\n    hue: 0,\n    lightness: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    removeAlpha: false,\n    ensureAlpha: -1,\n    colourspace: 'srgb',\n    colourspaceInput: 'last',\n    composite: [],\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    withMetadata: false,\n    withMetadataOrientation: -1,\n    withMetadataDensity: 0,\n    withMetadataIcc: '',\n    withMetadataStrs: {},\n    resolveWithObject: false,\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    jpegOptimiseCoding: true,\n    jpegQuantisationTable: 0,\n    pngProgressive: false,\n    pngCompressionLevel: 6,\n    pngAdaptiveFiltering: false,\n    pngPalette: false,\n    pngQuality: 100,\n    pngEffort: 7,\n    pngBitdepth: 8,\n    pngDither: 1,\n    jp2Quality: 80,\n    jp2TileHeight: 512,\n    jp2TileWidth: 512,\n    jp2Lossless: false,\n    jp2ChromaSubsampling: '4:4:4',\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    webpSmartSubsample: false,\n    webpEffort: 4,\n    gifBitdepth: 8,\n    gifEffort: 7,\n    gifDither: 1,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'horizontal',\n    tiffPyramid: false,\n    tiffBitdepth: 8,\n    tiffTile: false,\n    tiffTileHeight: 256,\n    tiffTileWidth: 256,\n    tiffXres: 1.0,\n    tiffYres: 1.0,\n    tiffResolutionUnit: 'inch',\n    heifQuality: 50,\n    heifLossless: false,\n    heifCompression: 'av1',\n    heifEffort: 4,\n    heifChromaSubsampling: '4:4:4',\n    rawDepth: 'uchar',\n    tileSize: 256,\n    tileOverlap: 0,\n    tileContainer: 'fs',\n    tileLayout: 'dz',\n    tileFormat: 'last',\n    tileDepth: 'last',\n    tileAngle: 0,\n    tileSkipBlanks: -1,\n    tileBackground: [255, 255, 255, 255],\n    tileCentre: false,\n    tileId: 'https://example.com/iiif',\n    timeoutSeconds: 0,\n    linearA: 1,\n    linearB: 0,\n    // Function to notify of libvips warnings\n    debuglog: warning => {\n      this.emit('warning', warning);\n      debuglog(warning);\n    },\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      Sharp.queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, {\n    allowStream: true\n  });\n  return this;\n};\n\nObject.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);\nObject.setPrototypeOf(Sharp, stream.Duplex);\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @example\n * // Create a pipeline that will download an image, resize it and format it to different files\n * // Using Promises to know when the pipeline is complete\n * const fs = require(\"fs\");\n * const got = require(\"got\");\n * const sharpStream = sharp({ failOn: 'none' });\n *\n * const promises = [];\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .jpeg({ quality: 100 })\n *     .toFile(\"originalFile.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .jpeg({ quality: 80 })\n *     .toFile(\"optimized-500.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .webp({ quality: 80 })\n *     .toFile(\"optimized-500.webp\")\n * );\n *\n * // https://github.com/sindresorhus/got#gotstreamurl-options\n * got.stream(\"https://www.example.com/some-file.jpg\").pipe(sharpStream);\n *\n * Promise.all(promises)\n *   .then(res => { console.log(\"Done!\", res); })\n *   .catch(err => {\n *     console.error(\"Error processing files, let's clean it up\", err);\n *     try {\n *       fs.unlinkSync(\"originalFile.jpg\");\n *       fs.unlinkSync(\"optimized-500.jpg\");\n *       fs.unlinkSync(\"optimized-500.webp\");\n *     } catch (e) {}\n *   });\n *\n * @returns {Sharp}\n */\n\nfunction clone() {\n  // Clone existing options\n  const clone = this.constructor.call();\n  clone.options = Object.assign({}, this.options); // Pass 'finish' event to clone for Stream-based input\n\n  if (this._isStreamInput()) {\n    this.on('finish', () => {\n      // Clone inherits input data\n      this._flattenBufferIn();\n\n      clone.options.bufferIn = this.options.bufferIn;\n      clone.emit('finish');\n    });\n  }\n\n  return clone;\n}\n\nObject.assign(Sharp.prototype, {\n  clone\n});\n/**\n * Export constructor.\n * @private\n */\n\nmodule.exports = Sharp;","map":{"version":3,"sources":["D:/Marcos Muni/Proyecto Muni/Gitinspecobras/inspecobras/client/node_modules/sharp/lib/constructor.js"],"names":["util","require","stream","is","hasVendoredLibvips","debuglog","Sharp","input","options","arguments","length","defined","Error","Duplex","call","topOffsetPre","leftOffsetPre","widthPre","heightPre","topOffsetPost","leftOffsetPost","widthPost","heightPost","width","height","canvas","position","resizeBackground","useExifOrientation","angle","rotationAngle","rotationBackground","rotateBeforePreExtract","flip","flop","extendTop","extendBottom","extendLeft","extendRight","extendBackground","withoutEnlargement","withoutReduction","affineMatrix","affineBackground","affineIdx","affineIdy","affineOdx","affineOdy","affineInterpolator","constructor","interpolators","bilinear","kernel","fastShrinkOnLoad","tintA","tintB","flatten","flattenBackground","negate","negateAlpha","medianSize","blurSigma","sharpenSigma","sharpenM1","sharpenM2","sharpenX1","sharpenY2","sharpenY3","threshold","thresholdGrayscale","trimThreshold","gamma","gammaOut","greyscale","normalise","claheWidth","claheHeight","claheMaxSlope","brightness","saturation","hue","lightness","booleanBufferIn","booleanFileIn","joinChannelIn","extractChannel","removeAlpha","ensureAlpha","colourspace","colourspaceInput","composite","fileOut","formatOut","streamOut","withMetadata","withMetadataOrientation","withMetadataDensity","withMetadataIcc","withMetadataStrs","resolveWithObject","jpegQuality","jpegProgressive","jpegChromaSubsampling","jpegTrellisQuantisation","jpegOvershootDeringing","jpegOptimiseScans","jpegOptimiseCoding","jpegQuantisationTable","pngProgressive","pngCompressionLevel","pngAdaptiveFiltering","pngPalette","pngQuality","pngEffort","pngBitdepth","pngDither","jp2Quality","jp2TileHeight","jp2TileWidth","jp2Lossless","jp2ChromaSubsampling","webpQuality","webpAlphaQuality","webpLossless","webpNearLossless","webpSmartSubsample","webpEffort","gifBitdepth","gifEffort","gifDither","tiffQuality","tiffCompression","tiffPredictor","tiffPyramid","tiffBitdepth","tiffTile","tiffTileHeight","tiffTileWidth","tiffXres","tiffYres","tiffResolutionUnit","heifQuality","heifLossless","heifCompression","heifEffort","heifChromaSubsampling","rawDepth","tileSize","tileOverlap","tileContainer","tileLayout","tileFormat","tileDepth","tileAngle","tileSkipBlanks","tileBackground","tileCentre","tileId","timeoutSeconds","linearA","linearB","warning","emit","queueListener","queueLength","queue","_createInputDescriptor","allowStream","Object","setPrototypeOf","prototype","clone","assign","_isStreamInput","on","_flattenBufferIn","bufferIn","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AAEAA,OAAO,CAAC,WAAD,CAAP,CAAqBG,kBAArB;;AACAH,OAAO,CAAC,SAAD,CAAP,C,CAEA;;;AACA,MAAMI,QAAQ,GAAGL,IAAI,CAACK,QAAL,CAAc,OAAd,CAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,KAAK,GAAG,UAAUC,KAAV,EAAiBC,OAAjB,EAA0B;AACtC,MAAIC,SAAS,CAACC,MAAV,KAAqB,CAArB,IAA0B,CAACP,EAAE,CAACQ,OAAH,CAAWJ,KAAX,CAA/B,EAAkD;AAChD,UAAM,IAAIK,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,MAAI,EAAE,gBAAgBN,KAAlB,CAAJ,EAA8B;AAC5B,WAAO,IAAIA,KAAJ,CAAUC,KAAV,EAAiBC,OAAjB,CAAP;AACD;;AACDN,EAAAA,MAAM,CAACW,MAAP,CAAcC,IAAd,CAAmB,IAAnB;AAC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","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst stream = require('stream');\nconst is = require('./is');\n\nrequire('./libvips').hasVendoredLibvips();\nrequire('./sharp');\n\n// Use NODE_DEBUG=sharp to enable libvips warnings\nconst debuglog = util.debuglog('sharp');\n\n/**\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG, WebP, GIF, AVIF or TIFF format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Non-critical problems encountered during processing are emitted as `warning` events.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * @constructs Sharp\n *\n * @emits Sharp#info\n * @emits Sharp#warning\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from readableStream,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * var transformer = sharp()\n *   .resize(300)\n *   .on('info', function(info) {\n *     console.log('Image height is ' + info.height);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-transluent red pixels\n * sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @example\n * // Convert an animated GIF to an animated WebP\n * await sharp('in.gif', { animated: true }).toFile('out.webp');\n *\n * @example\n * // Read a raw array of pixels and save it to a png\n * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray\n * const image = sharp(input, {\n *   // because the input does not contain its dimensions or how many channels it has\n *   // we need to specify it in the constructor options\n *   raw: {\n *     width: 2,\n *     height: 1,\n *     channels: 3\n *   }\n * });\n * await image.toFile('my-two-pixels.png');\n *\n * @example\n * // Generate RGB Gaussian noise\n * await sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 3,\n *     noise: {\n *       type: 'gaussian',\n *       mean: 128,\n *       sigma: 30\n *     }\n *  }\n * }).toFile('noise.png');\n *\n * @param {(Buffer|Uint8Array|Uint8ClampedArray|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|string)} [input] - if present, can be\n *  a Buffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image data, or\n *  a TypedArray containing raw pixel image data, or\n *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.\n *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string} [options.failOn='warning'] - level of sensitivity to invalid images, one of (in order of sensitivity): 'none' (least), 'truncated', 'error' or 'warning' (most), highers level imply lower levels.\n * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels\n *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.\n *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).\n * @param {boolean} [options.unlimited=false] - Set this to `true` to remove safety features that help prevent memory exhaustion (SVG, PNG).\n * @param {boolean} [options.sequentialRead=false] - Set this to `true` to use sequential rather than random access where possible.\n *  This can reduce memory usage and might improve performance on some systems.\n * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.\n * @param {number} [options.pages=1] - number of pages to extract for multi-page input (GIF, WebP, AVIF, TIFF, PDF), use -1 for all pages.\n * @param {number} [options.page=0] - page number to start extracting from for multi-page input (GIF, WebP, AVIF, TIFF, PDF), zero based.\n * @param {number} [options.subifd=-1] - subIFD (Sub Image File Directory) to extract for OME-TIFF, defaults to main image.\n * @param {number} [options.level=0] - level to extract from a multi-level input (OpenSlide), zero based.\n * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (equivalent of setting `pages` to `-1`).\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {number} [options.raw.width] - integral number of pixels wide.\n * @param {number} [options.raw.height] - integral number of pixels high.\n * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.\n * @param {boolean} [options.raw.premultiplied] - specifies that the raw input has already been premultiplied, set to `true`\n *  to avoid sharp premultiplying the image. (optional, default `false`)\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {number} [options.create.width] - integral number of pixels wide.\n * @param {number} [options.create.height] - integral number of pixels high.\n * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).\n * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [options.create.noise] - describes a noise to be created.\n * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.\n * @param {number} [options.create.noise.mean] - mean of pixels in generated noise.\n * @param {number} [options.create.noise.sigma] - standard deviation of pixels in generated noise.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nconst Sharp = function (input, options) {\n  if (arguments.length === 1 && !is.defined(input)) {\n    throw new Error('Invalid input');\n  }\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n  stream.Duplex.call(this);\n  this.options = {\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    position: 0,\n    resizeBackground: [0, 0, 0, 255],\n    useExifOrientation: false,\n    angle: 0,\n    rotationAngle: 0,\n    rotationBackground: [0, 0, 0, 255],\n    rotateBeforePreExtract: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    extendBackground: [0, 0, 0, 255],\n    withoutEnlargement: false,\n    withoutReduction: false,\n    affineMatrix: [],\n    affineBackground: [0, 0, 0, 255],\n    affineIdx: 0,\n    affineIdy: 0,\n    affineOdx: 0,\n    affineOdy: 0,\n    affineInterpolator: this.constructor.interpolators.bilinear,\n    kernel: 'lanczos3',\n    fastShrinkOnLoad: true,\n    // operations\n    tintA: 128,\n    tintB: 128,\n    flatten: false,\n    flattenBackground: [0, 0, 0],\n    negate: false,\n    negateAlpha: true,\n    medianSize: 0,\n    blurSigma: 0,\n    sharpenSigma: 0,\n    sharpenM1: 1,\n    sharpenM2: 2,\n    sharpenX1: 2,\n    sharpenY2: 10,\n    sharpenY3: 20,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimThreshold: 0,\n    gamma: 0,\n    gammaOut: 0,\n    greyscale: false,\n    normalise: false,\n    claheWidth: 0,\n    claheHeight: 0,\n    claheMaxSlope: 3,\n    brightness: 1,\n    saturation: 1,\n    hue: 0,\n    lightness: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    removeAlpha: false,\n    ensureAlpha: -1,\n    colourspace: 'srgb',\n    colourspaceInput: 'last',\n    composite: [],\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    withMetadata: false,\n    withMetadataOrientation: -1,\n    withMetadataDensity: 0,\n    withMetadataIcc: '',\n    withMetadataStrs: {},\n    resolveWithObject: false,\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    jpegOptimiseCoding: true,\n    jpegQuantisationTable: 0,\n    pngProgressive: false,\n    pngCompressionLevel: 6,\n    pngAdaptiveFiltering: false,\n    pngPalette: false,\n    pngQuality: 100,\n    pngEffort: 7,\n    pngBitdepth: 8,\n    pngDither: 1,\n    jp2Quality: 80,\n    jp2TileHeight: 512,\n    jp2TileWidth: 512,\n    jp2Lossless: false,\n    jp2ChromaSubsampling: '4:4:4',\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    webpSmartSubsample: false,\n    webpEffort: 4,\n    gifBitdepth: 8,\n    gifEffort: 7,\n    gifDither: 1,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'horizontal',\n    tiffPyramid: false,\n    tiffBitdepth: 8,\n    tiffTile: false,\n    tiffTileHeight: 256,\n    tiffTileWidth: 256,\n    tiffXres: 1.0,\n    tiffYres: 1.0,\n    tiffResolutionUnit: 'inch',\n    heifQuality: 50,\n    heifLossless: false,\n    heifCompression: 'av1',\n    heifEffort: 4,\n    heifChromaSubsampling: '4:4:4',\n    rawDepth: 'uchar',\n    tileSize: 256,\n    tileOverlap: 0,\n    tileContainer: 'fs',\n    tileLayout: 'dz',\n    tileFormat: 'last',\n    tileDepth: 'last',\n    tileAngle: 0,\n    tileSkipBlanks: -1,\n    tileBackground: [255, 255, 255, 255],\n    tileCentre: false,\n    tileId: 'https://example.com/iiif',\n    timeoutSeconds: 0,\n    linearA: 1,\n    linearB: 0,\n    // Function to notify of libvips warnings\n    debuglog: warning => {\n      this.emit('warning', warning);\n      debuglog(warning);\n    },\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      Sharp.queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, { allowStream: true });\n  return this;\n};\nObject.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);\nObject.setPrototypeOf(Sharp, stream.Duplex);\n\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @example\n * // Create a pipeline that will download an image, resize it and format it to different files\n * // Using Promises to know when the pipeline is complete\n * const fs = require(\"fs\");\n * const got = require(\"got\");\n * const sharpStream = sharp({ failOn: 'none' });\n *\n * const promises = [];\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .jpeg({ quality: 100 })\n *     .toFile(\"originalFile.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .jpeg({ quality: 80 })\n *     .toFile(\"optimized-500.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .webp({ quality: 80 })\n *     .toFile(\"optimized-500.webp\")\n * );\n *\n * // https://github.com/sindresorhus/got#gotstreamurl-options\n * got.stream(\"https://www.example.com/some-file.jpg\").pipe(sharpStream);\n *\n * Promise.all(promises)\n *   .then(res => { console.log(\"Done!\", res); })\n *   .catch(err => {\n *     console.error(\"Error processing files, let's clean it up\", err);\n *     try {\n *       fs.unlinkSync(\"originalFile.jpg\");\n *       fs.unlinkSync(\"optimized-500.jpg\");\n *       fs.unlinkSync(\"optimized-500.webp\");\n *     } catch (e) {}\n *   });\n *\n * @returns {Sharp}\n */\nfunction clone () {\n  // Clone existing options\n  const clone = this.constructor.call();\n  clone.options = Object.assign({}, this.options);\n  // Pass 'finish' event to clone for Stream-based input\n  if (this._isStreamInput()) {\n    this.on('finish', () => {\n      // Clone inherits input data\n      this._flattenBufferIn();\n      clone.options.bufferIn = this.options.bufferIn;\n      clone.emit('finish');\n    });\n  }\n  return clone;\n}\nObject.assign(Sharp.prototype, { clone });\n\n/**\n * Export constructor.\n * @private\n */\nmodule.exports = Sharp;\n"]},"metadata":{},"sourceType":"script"}